<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Hello World!</title>
  </head>
  <body>
    <h1>Hello World!</h1>
    We are using node <script>document.write(process.versions.node)</script>,<br />
    Chrome <script>document.write(process.versions.chrome)</script>,<br />
    and Electron <script>document.write(process.versions.electron)</script>.<br />
    <!--<webview id="foo" src="https://www.taobao.com/" style="display:inline-flex; width:640px; height:480px">
      <span id="indicator"></span>
    </webview>-->
    <script>
      const electron = require('electron');
      const ipcRenderer = electron.ipcRenderer;
      
      // 监听webContents.send主动传递的消息。
      ipcRenderer.on('main-process-messages', (event, message) => {
        console.log('message from Main Process: ' , message);  // Prints Main Process Message.
      });
      
      // 使用ipcRenderer触发同步消息
      console.log('synchronous-message: ', ipcRenderer.sendSync('synchronous-message', 'ping'));
      
      // 使用ipcRenderer触发异步消息，消息结果使用监听来完成。
      ipcRenderer.on('asynchronous-reply', (event, arg) => {
        console.log('asynchronous-reply: %O %O', event, arg);
      });
      console.log('asynchronous-reply return value: ', ipcRenderer.send('asynchronous-message', 'ping'));
    </script>
    <!--<script>
      // webview标签逻辑
      onload = () => {
        const webview = document.getElementById('foo');
        const indicator = document.querySelector('#indicator');

        const loadstart = () => {
          indicator.innerText = 'loading...';
        };

        const loadstop = () => {
          indicator.innerText = '';
        };

        webview.addEventListener('did-start-loading', loadstart);
        webview.addEventListener('did-stop-loading', loadstop);
      };
    </script>-->
    <script>
      // Memu
      // context Menu
      const {remote} = require('electron');
      const {Menu, MenuItem} = remote;

      const contextMenu = new Menu();
      contextMenu.append(new MenuItem({label: 'MenuItem1', click() { console.log('item 1 clicked'); }}));
      contextMenu.append(new MenuItem({type: 'separator'}));
      contextMenu.append(new MenuItem({label: 'MenuItem2', type: 'checkbox', checked: true, click(e) { console.log('item 2 clicked. args = %O', args); }}));

      window.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        contextMenu.popup(remote.getCurrentWindow());
      }, false);
      
      // Application Menu
      const template = [ {
        label: 'Edit',
        submenu: [ {
          label: 'Undo',
          accelerator: 'CmdOrCtrl+Z',
          role: 'undo'
        }, {
          label: 'Redo',
          accelerator: 'Shift+CmdOrCtrl+Z',
          role: 'redo'
        }, {
          type: 'separator'
        }, {
          label: 'Cut',
          accelerator: 'CmdOrCtrl+X',
          role: 'cut'
        }, {
          label: 'Copy',
          accelerator: 'CmdOrCtrl+C',
          role: 'copy'
        }, {
          label: 'Paste',
          accelerator: 'CmdOrCtrl+V',
          role: 'paste'
        }, {
          label: 'Select All',
          accelerator: 'CmdOrCtrl+A',
          role: 'selectall'
        } ]
      }, {
        label: 'View',
        submenu: [ {
          label: 'Reload',
          accelerator: 'CmdOrCtrl+R',
          click(item, focusedWindow) {
            if (focusedWindow) focusedWindow.reload();
          }
        }, {
          label: 'Toggle Full Screen',
          accelerator: process.platform === 'darwin' ? 'Ctrl+Command+F' : 'F11',
          click(item, focusedWindow) {
            if (focusedWindow)
              focusedWindow.setFullScreen(!focusedWindow.isFullScreen());
          }
        }, {
          label: 'Toggle Developer Tools',
          accelerator: process.platform === 'darwin' ? 'Alt+Command+I' : 'Ctrl+Shift+I',
          click(item, focusedWindow) {
            if (focusedWindow)
              focusedWindow.webContents.toggleDevTools();
          }
        } ]
      }, {
        label: 'Window',
        role: 'window',
        submenu: [ {
          label: 'Minimize',
          accelerator: 'CmdOrCtrl+M',
          role: 'minimize'
        }, {
          label: 'Close',
          accelerator: 'CmdOrCtrl+W',
          role: 'close'
        } ]
      }, {
        label: 'Help',
        role: 'help',
        submenu: [ {
          label: 'Learn More',
          click() { require('electron').shell.openExternal('http://electron.atom.io'); }
        } ]
      } ];

      if (process.platform === 'darwin') {
        const app = require('electron').remote.app;
        const name = app.getName();
        template.unshift({
          label: name,
          submenu: [ {
            label: 'About ' + name,
            role: 'about'
          }, {
            type: 'separator'
          }, {
            label: 'Services',
            role: 'services',
            submenu: []
          }, {
            type: 'separator'
          }, {
            label: 'Hide ' + name,
            accelerator: 'Command+H',
            role: 'hide'
          }, {
            label: 'Hide Others',
            accelerator: 'Command+Alt+H',
            role: 'hideothers'
          }, {
            label: 'Show All',
            role: 'unhide'
          }, {
            type: 'separator'
          }, {
            label: 'Quit',
            accelerator: 'Command+Q',
            click() { app.quit(); }
          } ]
        });
        // Window menu.
        template[3].submenu.push( {
          type: 'separator'
        }, {
          label: 'Bring All to Front',
          role: 'front'
        } );
      }

      const appMenu = Menu.buildFromTemplate(template);
      Menu.setApplicationMenu(appMenu);
    </script>
  </body>
</html>